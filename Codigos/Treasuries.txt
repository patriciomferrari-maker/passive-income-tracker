// ===================================================================
// FUNCIONES AUXILIARES GLOBALES
// ===================================================================

/**
 * Agrega o resta meses a una fecha dada.
 * @param {Date} d La fecha inicial.
 * @param {number} months El número de meses a agregar (puede ser negativo).
 * @returns {Date} La nueva fecha.
 */
function addMonths(d, months) { 
  return new Date(d.getFullYear(), d.getMonth() + months, d.getDate()); 
}

/**
 * Calcula la diferencia exacta en días entre dos fechas.
 * @param {Date} d1 La primera fecha.
 * @param {Date} d2 La segunda fecha.
 * @returns {number} El número de días.
 */
function daysBetweenExact(d1, d2) {
  const a = Date.UTC(d1.getFullYear(), d1.getMonth(), d1.getDate());
  const b = Date.UTC(d2.getFullYear(), d2.getMonth(), d2.getDate());
  return Math.round((b - a) / (1000*3600*24));
}

/**
 * Formatea una fecha en formato "YYYY-MM-DD" para usar como clave (key).
 * @param {Date} d La fecha a formatear.
 * @returns {string} La clave de fecha.
 */
function fmtDateKey(d) {
  if (!(d instanceof Date) || isNaN(d)) return "";
  const yy = d.getFullYear();
  const mm = (d.getMonth()+1).toString().padStart(2,"0");
  const dd = d.getDate().toString().padStart(2,"0");
  return `${yy}-${mm}-${dd}`;
}

// ===================================================================
// FUNCIÓN PRINCIPAL DE CÁLCULO Y ESCRITURA (Motor Central para Treasuries)
// ===================================================================

/**
 * Función principal para generar el detalle de cashflow, calendario, y calcular la TIR
 * para la cartera de Treasuries.
 */
function generarTodoTreasuries() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const baseSheet = ss.getSheetByName("Base Operaciones Treasuries");
  
  if (!baseSheet) { 
    SpreadsheetApp.getUi().alert("No existe la hoja 'Base Operaciones Treasuries'. Asegúrate de que el nombre sea correcto."); 
    return; 
  }
  
  const baseLast = baseSheet.getLastRow();
  if (baseLast < 2) { 
    SpreadsheetApp.getUi().alert("No hay datos en 'Base Operaciones Treasuries'."); 
    return; 
  }

  // No necesitamos leer el esquema de amortización programada para Treasuries.
  
  const baseCols = baseSheet.getLastColumn();
  const baseValues = baseSheet.getRange(2,1, baseLast-1, baseCols).getValues();
  const baseDisplay = baseSheet.getRange(2,1, baseLast-1, baseCols).getDisplayValues();

  const detalleHeader = ["Ticker","Nombre Treasury","Fecha Operación","Tipo Flujo","Capital Inicial","Capital Residual","Tasa Aplicada (%)","Pago Interés","Pago Capital","Total Flujo","Moneda"];

  const purchasesByTicker = {};   
  const nameByTicker = {};
  
  for (let i = 0; i < baseValues.length; i++) {
    const row = baseValues[i];
    const disp = baseDisplay[i];
    const ticker = (row[0] || "").toString().trim();
    if (!ticker) continue;
    
    const nombre = (row[1] || "").toString();
    if (nombre && !nameByTicker[ticker]) nameByTicker[ticker] = nombre;

    const fechaCompra = row[2] instanceof Date ? row[2] : (row[2] ? new Date(row[2]) : null);
    const precioCompra = Number(row[3]) || 0;
    const cantidad = Number(row[4]) || 0;
    const comision = Number(row[5]) || 0;
    const moneda = (row[6] || "USD").toString().toUpperCase(); // Default USD para Treasuries
    const capitalNominal = Number(row[7]) || (precioCompra * cantidad);
    const fechaVto = row[8] instanceof Date ? row[8] : (row[8] ? new Date(row[8]) : null);

    const cuponDisplay = (disp[9] === undefined ? "" : disp[9]);
    const cuponRaw = (row[9] === "" || row[9] === null) ? 0 : row[9];
    let annualRate = 0;
    if (isFinite(Number(cuponRaw)) && Number(cuponRaw) !== 0) {
      const numericRaw = Number(cuponRaw);
      annualRate = (numericRaw > 1) ? (numericRaw / 100) : numericRaw; 
    } else {
      annualRate = 0;
    }

    const frecuenciaTxt = (row[10] || "SEMESTRAL").toString().toUpperCase(); // Default SEMESTRAL para Treasuries
    const tipoAmort = (row[11] || "BULLET").toString().toUpperCase(); // Default BULLET
    const fechaEmision = row[12] instanceof Date ? row[12] : (row[12] ? new Date(row[12]) : null); 
    
    if (!fechaCompra || !fechaVto || capitalNominal <= 0) continue;

    let freqMonths = 6; // Por defecto Semestral (6 meses)
    if (/SEMESTR|^SEM/i.test(frecuenciaTxt)) freqMonths = 6;
    else if (/TRIM|TRI/i.test(frecuenciaTxt)) freqMonths = 3;
    else if (/MENS|MENSUAL/i.test(frecuenciaTxt) || /\bMES\b/i.test(frecuenciaTxt)) freqMonths = 1;
    else if (/ANU|AÑO|ANUAL/i.test(frecuenciaTxt)) freqMonths = 12;
    else {
      const possible = Number(frecuenciaTxt);
      if (isFinite(possible) && possible > 0) freqMonths = possible;
    }

    purchasesByTicker[ticker] = purchasesByTicker[ticker] || [];
    purchasesByTicker[ticker].push({
      fechaCompra,
      precioCompra,
      cantidad,
      comision,
      moneda,
      capitalNominal: Number(capitalNominal),
      fechaVto,
      annualRate,
      cuponDisplay,
      tipoAmort,
      freqMonths,
      fechaEmision
    });
  }

  const aggFlows = {};
  const contributionsByPurchase = {}; 

  Object.keys(purchasesByTicker).forEach(ticker => {
    const purchases = purchasesByTicker[ticker];
    if (!purchases || purchases.length === 0) return;

    const fechaVto = purchases[0].fechaVto;
    const freqMonths = purchases[0].freqMonths;
    const firstFechaEmision = purchases[0].fechaEmision; 
    const earliestPurchase = purchases.reduce((acc,p) => acc === null ? p.fechaCompra : (p.fechaCompra < acc ? p.fechaCompra : acc), null);

    // --- Generación del Schedule Contractual ---
    const rev = [];
    let cur = new Date(fechaVto.getFullYear(), fechaVto.getMonth(), fechaVto.getDate());
    rev.push(new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()));
    let guard = 0;
    while (true) {
      const prev = addMonths(cur, -freqMonths);
      // Evitamos pagos antes de la fecha de emisión o un loop infinito
      if (firstFechaEmision && prev.getTime() <= firstFechaEmision.getTime()) break; 
      rev.push(new Date(prev.getFullYear(), prev.getMonth(), prev.getDate()));
      cur = prev;
      guard++;
      if (guard > 500) break; // Límite de seguridad
    }
    rev.reverse(); 

    const scheduleDates = rev.filter(d => d.getTime() >= earliestPurchase.getTime());
    
    // Asegurarse de que al menos el vencimiento esté si se compró antes
    if (scheduleDates.length === 0 && fechaVto.getTime() >= earliestPurchase.getTime()) {
      scheduleDates.push(new Date(fechaVto.getFullYear(), fechaVto.getMonth(), fechaVto.getDate()));
    }
    // ------------------------------------------

    aggFlows[ticker] = aggFlows[ticker] || {};
    contributionsByPurchase[ticker] = [];

    purchases.forEach((pur, pIdx) => {
      const purchaseDate = pur.fechaCompra;
      let capitalForPurchase = Number(pur.capitalNominal); 
      const purchaseTipoAmort = pur.tipoAmort;
      const purchaseRate = Number(pur.annualRate); 
      const nPeriods = rev.length; 
      const purchaseEmision = pur.fechaEmision; 
      
      let principalPerPeriod = 0;
      if (purchaseTipoAmort === "AMORTIZING_LINEAR" && nPeriods > 0) principalPerPeriod = pur.capitalNominal / nPeriods;
      
      const contribs = {};

      for (let i = 0; i < scheduleDates.length; i++) {
        const payDate = scheduleDates[i];
        
        if (payDate.getTime() < purchaseDate.getTime()) continue; 
        
        let interestStartDate;
        
        // Determinar el inicio del período de interés
        if (i === 0) {
            let tempPrev = addMonths(payDate, -pur.freqMonths);
            if (!purchaseEmision || tempPrev.getTime() > purchaseEmision.getTime()) {
              interestStartDate = tempPrev;
            } else {
              // Si el primer pago cae después de la compra pero antes del primer cupón contractual,
              // el interés se calcula desde la fecha de emisión.
              interestStartDate = purchaseEmision;
            }
        } else {
            interestStartDate = scheduleDates[i-1];
        }

        if (interestStartDate.getTime() >= payDate.getTime()) continue; 

        const dias = Math.max(0, daysBetweenExact(interestStartDate, payDate));
        // Fórmula de interés simple: Capital * Tasa Anual * (Días / 365)
        const interest = Number((capitalForPurchase * purchaseRate * (dias/365)).toFixed(10));
        
        let capitalContrib = 0;
        // const dk = fmtDateKey(payDate);
        
        // --- Lógica de Amortización Simplificada para Treasuries (Bullet o Amortizing Linear) ---
        if (purchaseTipoAmort === "BULLET" || purchaseTipoAmort === "BALA") {
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
          
        } else if (purchaseTipoAmort === "AMORTIZING_LINEAR" || purchaseTipoAmort === "LINEAL") {
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
          else {
            capitalContrib = Math.min(Number(principalPerPeriod.toFixed(10)), capitalForPurchase);
          }
        // Nota: Se elimina la amortización PROGRAMADA
        } else { 
          // Si no se define o no coincide con los tipos soportados, asume Bullet al vencimiento
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
        }
        // ---------------------------------------------------------------------------------------
        
        capitalForPurchase = Math.max(0, capitalForPurchase - capitalContrib); 
        
        const dk = fmtDateKey(payDate);
        contribs[dk] = { interest: interest, capital: capitalContrib };
      }

      contributionsByPurchase[ticker].push({
        purchaseIndex: pIdx,
        fechaCompra: purchaseDate,
        capitalNominal: Number(pur.capitalNominal), 
        precioCompra: pur.precioCompra,
        cantidad: pur.cantidad,
        comision: pur.comision,
        moneda: pur.moneda,
        cuponDisplay: pur.cuponDisplay,
        annualRate: pur.annualRate,
        tipoAmort: pur.tipoAmort,
        freqMonths: pur.freqMonths,
        fechaEmision: pur.fechaEmision, 
        contribs: contribs
      });
    });

    const dateSet = new Set();
    contributionsByPurchase[ticker].forEach(pObj => {
      Object.keys(pObj.contribs).forEach(dk => {
        dateSet.add(dk);
        const dt = pObj.contribs[dk];
        aggFlows[ticker][dk] = aggFlows[ticker][dk] || { date: new Date(dk), mon: pObj.moneda, int:0, cap:0 };
        aggFlows[ticker][dk].int += dt.interest;
        aggFlows[ticker][dk].cap += dt.capital;
      });
    });

  }); 

  // --- Ahora calcula el Capital Residual ANTES de cada pago ---
  const residualByTickerByDate = {};
  const flowsByTickerForTIR = {}; 

  Object.keys(contributionsByPurchase).forEach(ticker => {
    residualByTickerByDate[ticker] = {};
    flowsByTickerForTIR[ticker] = [];

    const purchases = contributionsByPurchase[ticker].slice().sort((a,b) => a.fechaCompra - b.fechaCompra);

    const dateKeys = Object.keys(aggFlows[ticker] || {}).sort();
    
    const payDates = dateKeys.map(dk => {
      const parts = dk.split("-");
      return new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
    }).sort((a,b) => a - b);

    for (let pi = 0; pi < payDates.length; pi++) {
      const payDate = payDates[pi];
      const dk = fmtDateKey(payDate);
      
      let totalPurchasedBefore = 0;
      purchases.forEach(p => {
        if (p.fechaCompra.getTime() <= payDate.getTime()) totalPurchasedBefore += p.capitalNominal;
      });
      
      let capitalPaidPrior = 0;
      purchases.forEach(p => {
        Object.keys(p.contribs).forEach(dk2 => {
          const parts = dk2.split("-");
          const d2 = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
          if (d2.getTime() < payDate.getTime()) {
            capitalPaidPrior += p.contribs[dk2].capital;
          }
        });
      });
      
      // Capital Residual ANTES del pago actual
      const residualBefore = Number((totalPurchasedBefore - capitalPaidPrior).toFixed(10)); 
      residualByTickerByDate[ticker][dk] = residualBefore;
    }

    // Agrega el flujo negativo de la compra para el cálculo de TIR
    contributionsByPurchase[ticker].forEach(p => {
      const negativeCash = Number(-(p.precioCompra * p.cantidad + p.comision));
      flowsByTickerForTIR[ticker].push({ date: p.fechaCompra, amount: negativeCash });
    });

    // Agrega los flujos positivos de pagos para el cálculo de TIR
    Object.keys(aggFlows[ticker]).forEach(dk => {
      const obj = aggFlows[ticker][dk];
      const total = Number((obj.int + obj.cap).toFixed(10));
      flowsByTickerForTIR[ticker].push({ date: obj.date, amount: total });
    });

  }); 

  // --- 1. Construye las filas de salida y escribe en Detalle Cashflow Treasuries ---
  const purchaseRows = [];
  Object.keys(purchasesByTicker).forEach(ticker => {
    const arr = purchasesByTicker[ticker];
    arr.forEach(pur => {
      const displayRate = pur.cuponDisplay || "";
      const purchaseCash = Number(-(pur.precioCompra * pur.cantidad + pur.comision));
      
      // Fila de Compra
      purchaseRows.push([
        ticker, nameByTicker[ticker] || "", pur.fechaCompra, "Compra",
        Number(pur.capitalNominal), Number(pur.capitalNominal), displayRate,
        "", "", purchaseCash, pur.moneda 
      ]);
    });
  });

  const consolidatedRows = [];
  Object.keys(aggFlows).sort().forEach(ticker => {
    const name = nameByTicker[ticker] || "";
    const dateKeys = Object.keys(aggFlows[ticker]).sort();
    
    const displayRate = (purchasesByTicker[ticker] && purchasesByTicker[ticker][0]) 
      ? purchasesByTicker[ticker][0].cuponDisplay : "";

    dateKeys.forEach(dk => {
      const obj = aggFlows[ticker][dk];
      
      // OBTENER RESIDUAL BEFORE
      const residualBefore = parseFloat(residualByTickerByDate[ticker] && residualByTickerByDate[ticker][dk] !== undefined ? residualByTickerByDate[ticker][dk] : 0);
      
      // INTERÉS
      if ((obj.int || 0) !== 0) {
        // Fila de Interés
        consolidatedRows.push([
          ticker, name, obj.date, "Interés", "", residualBefore, displayRate, Number(obj.int), "", Number(obj.int), obj.mon 
        ]);
      }
      
      // AMORTIZACIÓN
      if ((obj.cap || 0) !== 0) {
        const capitalPagado = Number(obj.cap);
        
        // CALCULAR RESIDUAL AFTER
        const residualAfterValue = Math.max(0, residualBefore - capitalPagado); 
        
        // Fila de Amortización
        consolidatedRows.push([
          ticker, name, obj.date, "Amortización", "", 
          residualAfterValue, 
          displayRate, "", Number(capitalPagado), Number(capitalPagado), obj.mon 
        ]);
      }
    });
  });

  const detalleSheetName = "Detalle Cashflow Treasuries";
  const detalleSheet = ss.getSheetByName(detalleSheetName) || ss.insertSheet(detalleSheetName);
  detalleSheet.clear({ contentsOnly: true });
  
  let rowsToWrite = [detalleHeader].concat(purchaseRows).concat(consolidatedRows);
  
  // *** LÓGICA DE ORDENAMIENTO (Ticker > Fecha > Tipo Flujo) ***
  if (rowsToWrite.length > 1) {
      const dataRows = rowsToWrite.slice(1); 
      
      dataRows.sort((a, b) => {
        const tickerA = a[0]; 
        const tickerB = b[0]; 
        const dateA = a[2]; 
        const dateB = b[2];
        
        if (tickerA < tickerB) return -1;
        if (tickerA > tickerB) return 1;
        
        if (dateA.getTime() !== dateB.getTime()) {
          return dateA.getTime() - dateB.getTime();
        }
        
        const typeA = a[3]; 
        const typeB = b[3];
        // Compra siempre va primero si Ticker y Fecha son iguales
        if (typeA === "Compra") return -1; 
        if (typeB === "Compra") return 1;
        return 0;
      });
      
      rowsToWrite = [detalleHeader].concat(dataRows);
  }
  
  if (rowsToWrite.length > 0) detalleSheet.getRange(1,1,rowsToWrite.length, rowsToWrite[0].length).setValues(rowsToWrite);
  if (rowsToWrite.length > 1) detalleSheet.getRange(2,3,rowsToWrite.length-1,1).setNumberFormat("yyyy-mm-dd");

  // --- 2. Compute TIR per ticker and write to Base (col N = 14) ---
  const tirResults = [];
  Object.keys(flowsByTickerForTIR).forEach(tk => {
    const flows = flowsByTickerForTIR[tk];
    const mapByDate = {};
    flows.forEach(f => {
      const dk = fmtDateKey(f.date);
      mapByDate[dk] = mapByDate[dk] || { date: f.date, amt: 0 };
      mapByDate[dk].amt += f.amount;
    });
    const combined = Object.keys(mapByDate).map(k => mapByDate[k]).sort((a,b) => a.date - b.date);
    const amounts = combined.map(x => x.amt);
    const dates = combined.map(x => x.date);
    const tir = safeXIRR(amounts, dates);
    tirResults.push({ ticker: tk, tir: tir });
  });

  const tirColIndex = 14; // Columna N, asumiendo la misma estructura
  const tirValues = [];
  for (let i = 0; i < baseValues.length; i++) {
    const t = (baseValues[i][0] || "").toString().trim();
    const found = tirResults.find(x => x.ticker === t);
    tirValues.push([ found ? found.tir : "" ]);
  }
  
  // Asegúrate de que el rango de destino no exceda el número de filas de datos
  if (tirValues.length > 0) {
    baseSheet.getRange(2, tirColIndex, tirValues.length, 1).setValues(tirValues);
  }

  // --- 3. Construye el Calendario Consolidado ---
  const calendarAgg = {};
  Object.keys(aggFlows).forEach(tk => {
    Object.keys(aggFlows[tk]).forEach(dk => {
      const obj = aggFlows[tk][dk];
      const key = dk + "|" + obj.mon;
      calendarAgg[key] = calendarAgg[key] || { date: obj.date, mon: obj.mon, int:0, cap:0 };
      calendarAgg[key].int += obj.int;
      calendarAgg[key].cap += obj.cap;
    });
  });

  const calKeys = Object.keys(calendarAgg).sort();
  const calendarRows = [["Fecha","Moneda","Total Interés","Total Capital","Total Flujo"]];
  calKeys.forEach(k => {
    const v = calendarAgg[k];
    calendarRows.push([ v.date, v.mon, Number(v.int), Number(v.cap), Number(v.int + v.cap) ]);
  });

  const calSheetName = "Calendario Consolidado Treasuries";
  const calSheet = ss.getSheetByName(calSheetName) || ss.insertSheet(calSheetName);
  calSheet.clear({ contentsOnly: true });
  
  if (calendarRows.length > 0) calSheet.getRange(1,1,calendarRows.length, calendarRows[0].length).setValues(calendarRows);
  if (calendarRows.length > 1) calSheet.getRange(2,1,calendarRows.length-1,1).setNumberFormat("yyyy-mm-dd");

  // --- LLAMADA A LA FUNCIÓN DE ALERTAS (Se ejecuta al final) ---
  crearAlertasPagosTreasuries();

  SpreadsheetApp.getUi().alert("¡Generación completada! Detalle Cashflow Treasuries, Calendario Consolidado, TIR y Alertas automáticas creadas.");
}


// ===================================================================
// FUNCIÓN PARA LA AUTOMATIZACIÓN DE ALERTAS EN CALENDAR (FINAL)
// ===================================================================

/**
 * Lee la hoja "Detalle Cashflow Treasuries" y crea o actualiza eventos en Google Calendar 
 * para cada pago de Interés o Amortización que esté en el futuro.
 */
function crearAlertasPagosTreasuries() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const detalleSheet = ss.getSheetByName("Detalle Cashflow Treasuries");
  
  if (!detalleSheet) {
    Logger.log("La hoja 'Detalle Cashflow Treasuries' no existe. Ejecuta generarTodoTreasuries primero.");
    return;
  }

  const lastRow = detalleSheet.getLastRow();
  if (lastRow < 2) return;

  // --- BÚSQUEDA DEL CALENDARIO COMPARTIDO (MANTENEMOS EL MISMO ID DE EJEMPLO) ---
  // IMPORTANTE: REEMPLAZA ESTE ID con el ID de tu propio calendario si quieres usar uno específico.
  
  let calendar;
  try {
      calendar = CalendarApp.getCalendarById(CALENDAR_ID);
      Logger.log(`Usando calendario específico por ID para Treasuries.`);
  } catch (e) {
      calendar = CalendarApp.getDefaultCalendar(); 
      Logger.log(`ADVERTENCIA: No se pudo acceder al calendario con ID. Usando el calendario predeterminado.`);
  }
  // ---------------------------------------------------
  
  const now = new Date();
  
  // 1. Limpieza de Eventos Antiguos/Existentes
  const oneYearAgo = new Date();
  oneYearAgo.setFullYear(now.getFullYear() - 1);
  function addMonths(d, months) { return new Date(d.getFullYear(), d.getMonth() + months, d.getDate()); } 
  // Buscar eventos con el tag 'Pago Treasury (Automático)'
  const eventsToClean = calendar.getEvents(oneYearAgo, addMonths(now, 120), { search: 'Pago Treasury (Automático)' });
  
  eventsToClean.forEach(event => {
    if (event.getDescription().includes("Alerta generada por script Treasuries")) {
      event.deleteEvent();
    }
  });


  // 2. Creación de Nuevos Eventos Futuros
  const data = detalleSheet.getRange(2, 1, lastRow - 1, 11).getValues(); 
  let eventosCreados = 0;
  
  data.forEach(row => {
    // [0]Ticker, [1]Nombre, [2]Fecha, [3]Tipo Flujo, [9]Total Flujo, [10]Moneda
    const [ticker, nombre, fechaOperacion, tipoFlujo, , , , , , totalFlujo, moneda] = row;
    
    // Filtro 1: Solo Interés o Amortización
    if (tipoFlujo !== "Interés" && tipoFlujo !== "Amortización") return;
    
    // Filtro 2: Solo fechas futuras válidas
    if (!(fechaOperacion instanceof Date) || isNaN(fechaOperacion.getTime())) return; 
    if (fechaOperacion.getTime() < now.getTime()) return;
    
    // Título y detalles del evento
    const title = `${tipoFlujo} - ${ticker}: ${Number(totalFlujo).toFixed(2)} ${moneda} (Cuenta de USA)`;
    const description = `Título del Tesoro: ${nombre}\n` +
                        `Flujo: ${tipoFlujo}\n` +
                        `Monto: ${Number(totalFlujo).toFixed(2)} ${moneda}\n` +
                        `Tag: Pago Treasury (Automático).\n` + 
                        `Alerta generada por script Treasuries.`;

    // Evento de 30 minutos a las 10:00 AM del día de pago.
    const start = new Date(fechaOperacion.getFullYear(), fechaOperacion.getMonth(), fechaOperacion.getDate(), 10, 0, 0);
    const end = new Date(fechaOperacion.getFullYear(), fechaOperacion.getMonth(), fechaOperacion.getDate(), 10, 30, 0);

    const event = calendar.createEvent(title, start, end, { description: description });
    
    event.addPopupReminder(60); 
    eventosCreados++;
    
    // --- PAUSA AÑADIDA PARA EVITAR RATE LIMIT ---
    Utilities.sleep(200); 
    // -------------------------------------------
  });

  Logger.log(`Eventos de pago Treasury creados/actualizados en tu calendario: ${eventosCreados}`);
}

// ===================================================================
// FUNCIÓN PARA CÁLCULO DE TIR (Sin cambios, ya es genérica)
// ===================================================================

/**
 * Calcula la Tasa Interna de Retorno (TIR) para flujos de caja irregulares (XIRR).
 * Utiliza el método de Newton-Raphson para la convergencia.
 * @param {number[]} amounts Array de montos de flujo de caja.
 * @param {Date[]} dates Array de fechas correspondientes a los montos.
 * @returns {number|string} La TIR anual o una cadena vacía si falla el cálculo.
 */
function safeXIRR(amounts, dates) {
  if (!amounts || amounts.length < 2) return "";
  const hasPos = amounts.some(a => a > 0);
  const hasNeg = amounts.some(a => a < 0);
  if (!hasPos || !hasNeg) return "";
  
  const day0 = dates[0].getTime();
  const times = dates.map(d => (d.getTime() - day0) / (1000*3600*24));
  
  // Función para calcular el Valor Presente Neto (VPN)
  function npv(rate) {
    let s = 0;
    for (let i = 0; i < amounts.length; i++) s += amounts[i] / Math.pow(1 + rate, times[i]/365);
    return s;
  }
  
  // Función para calcular la derivada del VPN
  function d_npv(rate) {
    let s = 0;
    for (let i = 0; i < amounts.length; i++) s += - (times[i]/365) * amounts[i] / Math.pow(1 + rate, times[i]/365 + 1);
    return s;
  }
  
  // Intentar diferentes valores iniciales (guesses)
  const guesses = [0.05, 0.1, 0.01, -0.1, 0.2];
  for (let g=0; g<guesses.length; g++) {
    let x1 = guesses[g];
    try {
      for (let iter=0; iter<200; iter++) {
        const f = npv(x1), df = d_npv(x1);
        if (Math.abs(df) < 1e-12) break;
        const xNew = x1 - f/df;
        if (!isFinite(xNew)) break;
        if (Math.abs(xNew - x1) < 1e-9) { x1 = xNew; break; }
        x1 = xNew;
      }
      if (isFinite(x1) && Math.abs(npv(x1)) < 1e-4) return Number(x1.toFixed(10));
    } catch(e){}
  }
  return "";
}