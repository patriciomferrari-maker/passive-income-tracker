// NOTA: Se asume que la variable CALENDAR_ID está definida en otro archivo
// de script y es globalmente accesible.

// ===================================================================
// FUNCIONES AUXILIARES GLOBALES (CORREGIDAS Y VERIFICADAS)
// ===================================================================

/**
 * Agrega o resta meses a una fecha de forma segura, respetando el día del mes
 * sin exceder el último día del nuevo mes.
 */
function addMonths(d, months) { 
  const currentDay = d.getDate();
  // Crea la nueva fecha y hora. El setDate(0) asegura que no haya desbordamiento.
  const newDate = new Date(d.getFullYear(), d.getMonth() + months, d.getDate());
  
  // Esto maneja el desbordamiento (ej: 31 Ene + 1 Mes -> 03 Mar. Lo corrige a 28/29 Feb).
  if (newDate.getDate() < currentDay) {
    newDate.setDate(0); 
  }
  return newDate;
}

/**
 * Calcula la diferencia exacta de días entre dos fechas utilizando UTC 
 * para ignorar la hora y zona horaria local.
 */
function daysBetweenExact(d1, d2) {
  // Utilizamos los componentes de la fecha local para construir el timestamp UTC
  const a = Date.UTC(d1.getFullYear(), d1.getMonth(), d1.getDate());
  const b = Date.UTC(d2.getFullYear(), d2.getMonth(), d2.getDate());
  return Math.round((b - a) / (1000*3600*24));
}

/**
 * Formatea una fecha a AAAA-MM-DD.
 * CLAVE: Usamos métodos UTC (getUTCFullYear, getUTCMonth, getUTCDate)
 * para forzar que el día extraído sea el día exacto de la hoja,
 * evitando el "shift de un día" por la zona horaria.
 */
function fmtDateKey(d) {
  if (!(d instanceof Date) || isNaN(d)) return "";
  const yy = d.getUTCFullYear();
  const mm = (d.getUTCMonth()+1).toString().padStart(2,"0");
  const dd = d.getUTCDate().toString().padStart(2,"0");
  return `${yy}-${mm}-${dd}`;
}

// ===================================================================
// FUNCIONES DE LECTURA DE DATOS
// ===================================================================

function leerEsquemaAmortizacion(ss) {
  const amortSheet = ss.getSheetByName("Amortización ON");
  const esquema = {};
  
  if (!amortSheet) {
    Logger.log("No existe la hoja 'Amortización ON'. La amortización programada no se aplicará.");
    return esquema;
  }
  
  const lastRow = amortSheet.getLastRow();
  if (lastRow < 2) return esquema;

  const data = amortSheet.getRange(2, 1, lastRow - 1, 3).getValues();

  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const ticker = (row[0] || "").toString().trim();
    const fechaPago = row[1];
    let porcentaje = Number(row[2]) || 0; 

    if (!ticker || !(fechaPago instanceof Date)) continue;

    if (porcentaje > 1) porcentaje = porcentaje / 100;

    const fechaKey = fmtDateKey(fechaPago);
    
    esquema[ticker] = esquema[ticker] || {};
    esquema[ticker][fechaKey] = porcentaje;
  }
  
  return esquema;
}

// ===================================================================
// FUNCIÓN PRINCIPAL DE CÁLCULO Y ESCRITURA (Motor Central)
// ===================================================================

function generarTodoON() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const baseSheet = ss.getSheetByName("Base Operaciones ON");
  if (!baseSheet) { SpreadsheetApp.getUi().alert("No existe la hoja 'Base Operaciones ON'."); return; }
  const baseLast = baseSheet.getLastRow();
  if (baseLast < 2) { SpreadsheetApp.getUi().alert("No hay datos en 'Base Operaciones ON'."); return; }

  const esquemaAmortizacion = leerEsquemaAmortizacion(ss);

  const baseCols = baseSheet.getLastColumn();
  const baseValues = baseSheet.getRange(2,1, baseLast-1, baseCols).getValues();
  const baseDisplay = baseSheet.getRange(2,1, baseLast-1, baseCols).getDisplayValues();

  // Encabezados con columna 'Nota' eliminada.
  const detalleHeader = ["Ticker","Nombre ON","Fecha Operación","Tipo Flujo","Capital Inicial","Capital Residual","Tasa Aplicada (%)","Pago Interés","Pago Capital","Total Flujo","Moneda"];

  const purchasesByTicker = {};   
  const nameByTicker = {};
  for (let i = 0; i < baseValues.length; i++) {
    const row = baseValues[i];
    const disp = baseDisplay[i];
    const ticker = (row[0] || "").toString().trim();
    if (!ticker) continue;
    const nombre = (row[1] || "").toString();
    if (nombre && !nameByTicker[ticker]) nameByTicker[ticker] = nombre;

    const fechaCompra = row[2] instanceof Date ? row[2] : (row[2] ? new Date(row[2]) : null);
    const precioCompra = Number(row[3]) || 0;
    const cantidad = Number(row[4]) || 0;
    const comision = Number(row[5]) || 0;
    const moneda = (row[6] || "ARS").toString().toUpperCase();
    const capitalNominal = Number(row[7]) || (precioCompra * cantidad);
    const fechaVto = row[8] instanceof Date ? row[8] : (row[8] ? new Date(row[8]) : null);

    const cuponDisplay = (disp[9] === undefined ? "" : disp[9]);
    const cuponRaw = (row[9] === "" || row[9] === null) ? 0 : row[9];
    let annualRate = 0;
    if (isFinite(Number(cuponRaw)) && Number(cuponRaw) !== 0) {
      const numericRaw = Number(cuponRaw);
      annualRate = (numericRaw > 1) ? (numericRaw / 100) : numericRaw; 
    } else {
      annualRate = 0;
    }

    const frecuenciaTxt = (row[10] || "ANUAL").toString().toUpperCase();
    const tipoAmort = (row[11] || "BULLET").toString().toUpperCase();
    const fechaEmision = row[12] instanceof Date ? row[12] : (row[12] ? new Date(row[12]) : null); 
    
    if (!fechaCompra || !fechaVto) continue;

    let freqMonths = 12;
    if (/SEMESTR|^SEM/i.test(frecuenciaTxt)) freqMonths = 6;
    else if (/TRIM|TRI/i.test(frecuenciaTxt)) freqMonths = 3;
    else if (/MENS|MENSUAL/i.test(frecuenciaTxt) || /\bMES\b/i.test(frecuenciaTxt)) freqMonths = 1;
    else if (/SEMI/i.test(frecuenciaTxt)) freqMonths = 6;
    else if (/ANU|AÑO|ANUAL/i.test(frecuenciaTxt)) freqMonths = 12;
    else {
      const possible = Number(frecuenciaTxt);
      if (isFinite(possible) && possible > 0) freqMonths = possible;
    }

    purchasesByTicker[ticker] = purchasesByTicker[ticker] || [];
    purchasesByTicker[ticker].push({
      fechaCompra,
      precioCompra,
      cantidad,
      comision,
      moneda,
      capitalNominal: Number(capitalNominal),
      fechaVto,
      annualRate,
      cuponDisplay,
      tipoAmort,
      freqMonths,
      fechaEmision
    });
  }

  const aggFlows = {};
  const contributionsByPurchase = {}; 

  Object.keys(purchasesByTicker).forEach(ticker => {
    const purchases = purchasesByTicker[ticker];
    if (!purchases || purchases.length === 0) return;

    const fechaVto = purchases[0].fechaVto;
    const freqMonths = purchases[0].freqMonths;
    const firstFechaEmision = purchases[0].fechaEmision; 
    const earliestPurchase = purchases.reduce((acc,p) => acc === null ? p.fechaCompra : (p.fechaCompra < acc ? p.fechaCompra : acc), null);

    // --- Generación del Schedule Contractual (Punto de Corrección de Fechas) ---
    const rev = [];
    
    // Inicialización: Usamos los métodos de fecha LOCAL para obtener el día exacto de la hoja,
    // garantizando que el día (ej. 15) sea el punto de partida para el retroceso.
    let cur = new Date(fechaVto.getFullYear(), fechaVto.getMonth(), fechaVto.getDate());
    
    rev.push(new Date(cur.getFullYear(), cur.getMonth(), cur.getDate())); // Agrega Vto
    
    let guard = 0;
    while (true) {
      // Usa addMonths corregido para retroceder con precisión
      const prev = addMonths(cur, -freqMonths); 
      
      // La condición de parada asegura que no retroceda más allá de la compra más temprana o la emisión.
      if (earliestPurchase && prev.getTime() < earliestPurchase.getTime() && (!firstFechaEmision || prev.getTime() <= firstFechaEmision.getTime())) break; 
      
      rev.push(new Date(prev.getFullYear(), prev.getMonth(), prev.getDate()));
      cur = prev;
      guard++;
      if (guard > 500) break;
    }
    rev.reverse(); // Ordena de menor a mayor

    // Filtra las fechas que están antes de la primera compra
    const scheduleDates = rev.filter(d => d.getTime() >= earliestPurchase.getTime());
    
    // Si no se generó ninguna fecha pero Vto es posterior a la compra, agrega Vto
    if (scheduleDates.length === 0 && fechaVto.getTime() >= earliestPurchase.getTime()) {
      scheduleDates.push(new Date(fechaVto.getFullYear(), fechaVto.getMonth(), fechaVto.getDate()));
    }
    // ------------------------------------------

    aggFlows[ticker] = aggFlows[ticker] || {};
    contributionsByPurchase[ticker] = [];

    purchases.forEach((pur, pIdx) => {
      const purchaseDate = pur.fechaCompra;
      let capitalForPurchase = Number(pur.capitalNominal); 
      const purchaseTipoAmort = pur.tipoAmort;
      const purchaseRate = Number(pur.annualRate); 
      const nPeriods = rev.length; 
      const purchaseEmision = pur.fechaEmision; 
      
      let principalPerPeriod = 0;
      if (purchaseTipoAmort === "AMORTIZING_LINEAR" && nPeriods > 0) principalPerPeriod = pur.capitalNominal / nPeriods;
      
      const contribs = {};

      for (let i = 0; i < scheduleDates.length; i++) {
        const payDate = scheduleDates[i];
        
        if (payDate.getTime() < purchaseDate.getTime()) continue; 
        
        let interestStartDate;
        
        if (i === 0) {
            // Lógica de inicio de devengamiento para el primer pago
            let tempPrev = addMonths(payDate, -pur.freqMonths);
            
            if (purchaseEmision && tempPrev.getTime() < purchaseEmision.getTime()) {
                 interestStartDate = purchaseEmision;
            } else {
                 interestStartDate = tempPrev;
            }
        } else {
            interestStartDate = scheduleDates[i-1];
        }

        if (interestStartDate.getTime() >= payDate.getTime()) continue; 

        const dias = Math.max(0, daysBetweenExact(interestStartDate, payDate));
        const interest = Number((capitalForPurchase * purchaseRate * (dias/365)).toFixed(10));
        
        let capitalContrib = 0;
        const dk = fmtDateKey(payDate);
        
        // Lógica de Amortización
        if (purchaseTipoAmort === "BULLET") {
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
          
        } else if (purchaseTipoAmort === "AMORTIZING_LINEAR") {
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
          else {
              capitalContrib = Math.min(Number(principalPerPeriod.toFixed(10)), capitalForPurchase);
          }
          
        } else if (purchaseTipoAmort === "PROGRAMADA" && esquemaAmortizacion[ticker] && esquemaAmortizacion[ticker][dk] !== undefined) {
          const amortizacionPct = esquemaAmortizacion[ticker][dk]; 
          const capitalProgramado = Number((pur.capitalNominal * amortizacionPct).toFixed(10));
          capitalContrib = Math.min(capitalProgramado, capitalForPurchase); 

        } else {
          if (payDate.getTime() === fechaVto.getTime()) capitalContrib = Number(capitalForPurchase.toFixed(10));
        }
        
        capitalForPurchase = Math.max(0, capitalForPurchase - capitalContrib); 
        
        contribs[dk] = { interest: interest, capital: capitalContrib };
      }

      contributionsByPurchase[ticker].push({
        purchaseIndex: pIdx,
        fechaCompra: purchaseDate,
        capitalNominal: Number(pur.capitalNominal), 
        precioCompra: pur.precioCompra,
        cantidad: pur.cantidad,
        comision: pur.comision,
        moneda: pur.moneda,
        cuponDisplay: pur.cuponDisplay,
        annualRate: pur.annualRate,
        tipoAmort: pur.tipoAmort,
        freqMonths: pur.freqMonths,
        fechaEmision: pur.fechaEmision, 
        contribs: contribs
      });
    });

    const dateSet = new Set();
    contributionsByPurchase[ticker].forEach(pObj => {
      Object.keys(pObj.contribs).forEach(dk => {
        dateSet.add(dk);
        const dt = pObj.contribs[dk];
        // Al crear la fecha para el flujo agregado, se utiliza la clave UTC-safe
        aggFlows[ticker][dk] = aggFlows[ticker][dk] || { date: new Date(dk), mon: pObj.moneda, int:0, cap:0 };
        aggFlows[ticker][dk].int += dt.interest;
        aggFlows[ticker][dk].cap += dt.capital;
      });
    });

  }); 

  // --- Ahora calcula el Capital Residual ANTES de cada pago ---
  const residualByTickerByDate = {};
  const flowsByTickerForTIR = {}; 

  Object.keys(contributionsByPurchase).forEach(ticker => {
    residualByTickerByDate[ticker] = {};
    flowsByTickerForTIR[ticker] = [];

    const purchases = contributionsByPurchase[ticker].slice().sort((a,b) => a.fechaCompra - b.fechaCompra);

    const dateKeys = Object.keys(aggFlows[ticker] || {}).sort();
    
    const payDates = dateKeys.map(dk => {
      const parts = dk.split("-");
      // Recreamos la fecha usando los componentes extraídos de la clave UTC-safe
      return new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
    }).sort((a,b) => a - b);

    for (let pi = 0; pi < payDates.length; pi++) {
      const payDate = payDates[pi];
      const dk = fmtDateKey(payDate); // Usamos la clave UTC-safe
      let totalPurchasedBefore = 0;
      purchases.forEach(p => {
        if (p.fechaCompra.getTime() <= payDate.getTime()) totalPurchasedBefore += p.capitalNominal;
      });
      let capitalPaidPrior = 0;
      purchases.forEach(p => {
        Object.keys(p.contribs).forEach(dk2 => {
          const parts = dk2.split("-");
          const d2 = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
          if (d2.getTime() < payDate.getTime()) {
            capitalPaidPrior += p.contribs[dk2].capital;
          }
        });
      });
      // El valor guardado aquí es un STRING con 10 decimales.
      const residualBefore = Number((totalPurchasedBefore - capitalPaidPrior).toFixed(10)); 
      residualByTickerByDate[ticker][dk] = residualBefore;
    }

    contributionsByPurchase[ticker].forEach(p => {
      const negativeCash = Number(-(p.precioCompra * p.cantidad + p.comision));
      flowsByTickerForTIR[ticker].push({ date: p.fechaCompra, amount: negativeCash });
    });

    Object.keys(aggFlows[ticker]).forEach(dk => {
      const obj = aggFlows[ticker][dk];
      const total = Number((obj.int + obj.cap).toFixed(10));
      flowsByTickerForTIR[ticker].push({ date: obj.date, amount: total });
    });

  }); 

  // --- 1. Construye las filas de salida y escribe en Detalle Cashflow ON ---
  const purchaseRows = [];
  Object.keys(purchasesByTicker).forEach(ticker => {
    const arr = purchasesByTicker[ticker];
    arr.forEach(pur => {
      const displayRate = pur.cuponDisplay || "";
      const purchaseCash = Number(-(pur.precioCompra * pur.cantidad + pur.comision));
      
      // Homogeneización: "Compra"
      purchaseRows.push([
        ticker, nameByTicker[ticker] || "", pur.fechaCompra, "Compra",
        Number(pur.capitalNominal), Number(pur.capitalNominal), displayRate,
        "", "", purchaseCash, pur.moneda 
      ]);
    });
  });

  const consolidatedRows = [];
  Object.keys(aggFlows).sort().forEach(ticker => {
    const name = nameByTicker[ticker] || "";
    const dateKeys = Object.keys(aggFlows[ticker]).sort();
    
    const displayRate = (purchasesByTicker[ticker] && purchasesByTicker[ticker][0]) 
      ? purchasesByTicker[ticker][0].cuponDisplay : "";

    dateKeys.forEach(dk => {
      const obj = aggFlows[ticker][dk];
      
      // ⚠️ CORRECCIÓN FINAL SOLICITADA: SUMAR UN DÍA A LA FECHA DE FLUJO
      if (obj.date instanceof Date && !isNaN(obj.date)) {
          obj.date.setDate(obj.date.getDate() + 1);
      }
      
      // OBTENER RESIDUAL BEFORE
      const residualBefore = parseFloat(residualByTickerByDate[ticker] && residualByTickerByDate[ticker][dk] !== undefined ? residualByTickerByDate[ticker][dk] : 0);
      
      // INTERÉS
      if ((obj.int || 0) !== 0) {
        // Homogeneización: "Interés"
        consolidatedRows.push([
          ticker, name, obj.date, "Interés", "", residualBefore, displayRate, Number(obj.int), "", Number(obj.int), obj.mon 
        ]);
      }
      
      // AMORTIZACIÓN
      if ((obj.cap || 0) !== 0) {
        const capitalPagado = Number(obj.cap);
        
        // CALCULAR RESIDUAL AFTER (sin toFixed final)
        const residualAfterValue = Math.max(0, residualBefore - capitalPagado); 
        
        // Homogeneización: "Amortización"
        consolidatedRows.push([
          ticker, name, obj.date, "Amortización", "", 
          residualAfterValue, // ESCRIBIMOS EL NÚMERO FLOTANTE DIRECTAMENTE
          displayRate, "", Number(capitalPagado), Number(capitalPagado), obj.mon 
        ]);
      }
    });
  });

  const detalleSheet = ss.getSheetByName("Detalle Cashflow ON") || ss.insertSheet("Detalle Cashflow ON");
  detalleSheet.clear({ contentsOnly: true });
  
  let rowsToWrite = [detalleHeader].concat(purchaseRows).concat(consolidatedRows);
  
  // *** LÓGICA DE ORDENAMIENTO (Ticker > Fecha > Tipo Flujo) ***
  if (rowsToWrite.length > 1) {
      const dataRows = rowsToWrite.slice(1); 
      
      dataRows.sort((a, b) => {
        const tickerA = a[0]; 
        const tickerB = b[0]; 
        const dateA = a[2]; 
        const dateB = b[2];
        
        if (tickerA < tickerB) return -1;
        if (tickerA > tickerB) return 1;
        
        if (dateA.getTime() !== dateB.getTime()) {
          return dateA.getTime() - dateB.getTime();
        }
        
        const typeA = a[3]; 
        const typeB = b[3];
        // Compra siempre va primero si Ticker y Fecha son iguales
        if (typeA === "Compra") return -1; 
        if (typeB === "Compra") return 1;
        return 0;
      });
      
      rowsToWrite = [detalleHeader].concat(dataRows);
  }
  
  if (rowsToWrite.length > 0) detalleSheet.getRange(1,1,rowsToWrite.length, rowsToWrite[0].length).setValues(rowsToWrite);
  if (rowsToWrite.length > 1) detalleSheet.getRange(2,3,rowsToWrite.length-1,1).setNumberFormat("yyyy-mm-dd");

  // --- 2. Compute TIR per ticker and write to Base (col N = 14) ---
  const tirResults = [];
  Object.keys(flowsByTickerForTIR).forEach(tk => {
    const flows = flowsByTickerForTIR[tk];
    const mapByDate = {};
    flows.forEach(f => {
      const dk = fmtDateKey(f.date);
      mapByDate[dk] = mapByDate[dk] || { date: f.date, amt: 0 };
      mapByDate[dk].amt += f.amount;
    });
    const combined = Object.keys(mapByDate).map(k => mapByDate[k]).sort((a,b) => a.date - b.date);
    const amounts = combined.map(x => x.amt);
    const dates = combined.map(x => x.date);
    const tir = safeXIRR(amounts, dates);
    tirResults.push({ ticker: tk, tir: tir });
  });

  const tirColIndex = 14; // Columna N
  const tirValues = [];
  for (let i = 0; i < baseValues.length; i++) {
    const t = (baseValues[i][0] || "").toString().trim();
    const found = tirResults.find(x => x.ticker === t);
    tirValues.push([ found ? found.tir : "" ]);
  }
  baseSheet.getRange(2, tirColIndex, tirValues.length, 1).setValues(tirValues);

  // --- 3. Construye el Calendario Consolidado ---
  const calendarAgg = {};
  Object.keys(aggFlows).forEach(tk => {
    Object.keys(aggFlows[tk]).forEach(dk => {
      const obj = aggFlows[tk][dk];
      const key = fmtDateKey(obj.date) + "|" + obj.mon; // Usar la fecha corregida para la clave
      calendarAgg[key] = calendarAgg[key] || { date: obj.date, mon: obj.mon, int:0, cap:0 };
      calendarAgg[key].int += obj.int;
      calendarAgg[key].cap += obj.cap;
    });
  });

  const calKeys = Object.keys(calendarAgg).sort();
  const calendarRows = [["Fecha","Moneda","Total Interés","Total Capital","Total Flujo"]];
  calKeys.forEach(k => {
    const v = calendarAgg[k];
    calendarRows.push([ v.date, v.mon, Number(v.int), Number(v.cap), Number(v.int + v.cap) ]);
  });

  const calSheet = ss.getSheetByName("Calendario Consolidado ON") || ss.insertSheet("Calendario Consolidado ON");
  calSheet.clear({ contentsOnly: true });
  calSheet.getRange(1,1,calendarRows.length, calendarRows[0].length).setValues(calendarRows);
  if (calendarRows.length > 1) calSheet.getRange(2,1,calendarRows.length-1,1).setNumberFormat("yyyy-mm-dd");

  // --- LLAMADA A LA FUNCIÓN DE ALERTAS (Se ejecuta al final) ---
  crearAlertasPagosON();

  SpreadsheetApp.getUi().alert("Generado: Detalle Cashflow ON, Calendario Consolidado, TIR y ¡Alertas automáticas creadas en tu Google Calendar!");
}


// ===================================================================
// FUNCIÓN PARA LA AUTOMATIZACIÓN DE ALERTAS EN CALENDAR (FINAL)
// ===================================================================

/**
 * Lee la hoja "Detalle Cashflow ON" y crea o actualiza eventos en Google Calendar 
 * para cada pago de Interés o Amortización que esté en el futuro, usando el calendario compartido por ID.
 * ⚠️ Asume que CALENDAR_ID es globalmente accesible.
 */
function crearAlertasPagosON() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const detalleSheet = ss.getSheetByName("Detalle Cashflow ON");
  if (!detalleSheet) {
    Logger.log("La hoja 'Detalle Cashflow ON' no existe. Ejecuta generarTodoON primero.");
    return;
  }

  const lastRow = detalleSheet.getLastRow();
  if (lastRow < 2) return;

  // --- BÚSQUEDA DEL CALENDARIO COMPARTIDO (USANDO EL ID PROPORCIONADO) ---
  // Utilizamos la variable global CALENDAR_ID.
  
  let calendar;
  try {
      calendar = CalendarApp.getCalendarById(CALENDAR_ID);
      Logger.log(`Usando calendario específico por ID.`);
  } catch (e) {
      calendar = CalendarApp.getDefaultCalendar(); 
      Logger.log(`ADVERTENCIA: No se pudo acceder al calendario con ID. Usando el calendario predeterminado.`);
  }
  // ---------------------------------------------------
  
  const now = new Date();
  
  // 1. Limpieza de Eventos Antiguos/Existentes
  const oneYearAgo = new Date();
  oneYearAgo.setFullYear(now.getFullYear() - 1);
  // Se re-define addMonths localmente solo para evitar conflictos y asegurar el borrado.
  function addMonths(d, months) { return new Date(d.getFullYear(), d.getMonth() + months, d.getDate()); } 
  const eventsToClean = calendar.getEvents(oneYearAgo, addMonths(now, 120), { search: 'Pago ON (Automático)' });
  
  eventsToClean.forEach(event => {
    if (event.getDescription().includes("Alerta generada por script ON")) {
      event.deleteEvent();
    }
  });


  // 2. Creación de Nuevos Eventos Futuros
  const data = detalleSheet.getRange(2, 1, lastRow - 1, 11).getValues(); 
  let eventosCreados = 0;
  
  data.forEach(row => {
    // [0]Ticker, [1]Nombre ON, [2]Fecha, [3]Tipo Flujo, [9]Total Flujo, [10]Moneda
    const [ticker, nombreON, fechaOperacion, tipoFlujo, , , , , , totalFlujo, moneda] = row;
    
    // Filtro 1: Solo Interés o Amortización
    if (tipoFlujo !== "Interés" && tipoFlujo !== "Amortización") return;
    
    // Filtro 2: Solo fechas futuras válidas
    if (!(fechaOperacion instanceof Date) || isNaN(fechaOperacion.getTime())) return; 
    if (fechaOperacion.getTime() < now.getTime()) return;
    
    // Título y detalles del evento
    const title = `${tipoFlujo} - ${ticker}: ${Number(totalFlujo).toFixed(2)} ${moneda} (Cuenta Argentina)`;
    const description = `Obligación Negociable: ${nombreON}\n` +
                        `Flujo: ${tipoFlujo}\n` +
                        `Monto: ${Number(totalFlujo).toFixed(2)} ${moneda}\n` +
                        `Tag: Pago ON (Automático).\n` + 
                        `Alerta generada por script ON.`;

    // Evento de 30 minutos a las 10:00 AM del día de pago.
    const start = new Date(fechaOperacion.getFullYear(), fechaOperacion.getMonth(), fechaOperacion.getDate(), 10, 0, 0);
    const end = new Date(fechaOperacion.getFullYear(), fechaOperacion.getMonth(), fechaOperacion.getDate(), 10, 30, 0);

    const event = calendar.createEvent(title, start, end, { description: description });
    
    event.addPopupReminder(60); 
    eventosCreados++;
    
    // --- PAUSA AÑADIDA PARA EVITAR RATE LIMIT ---
    Utilities.sleep(200); 
    // -------------------------------------------
  });

  Logger.log(`Eventos de pago ON creados/actualizados en tu calendario: ${eventosCreados}`);
}

// ===================================================================
// FUNCIÓN PARA CÁLCULO DE TIR
// ===================================================================

function safeXIRR(amounts, dates) {
  if (!amounts || amounts.length < 2) return "";
  const hasPos = amounts.some(a => a > 0);
  const hasNeg = amounts.some(a => a < 0);
  if (!hasPos || !hasNeg) return "";
  const day0 = dates[0].getTime();
  const times = dates.map(d => (d.getTime() - day0) / (1000*3600*24));
  function npv(rate) {
    let s = 0;
    for (let i = 0; i < amounts.length; i++) s += amounts[i] / Math.pow(1 + rate, times[i]/365);
    return s;
  }
  function d_npv(rate) {
    let s = 0;
    for (let i = 0; i < amounts.length; i++) s += - (times[i]/365) * amounts[i] / Math.pow(1 + rate, times[i]/365 + 1);
    return s;
  }
  const guesses = [0.05,0.1,0.01,-0.1,0.2];
  for (let g=0; g<guesses.length; g++) {
    let x1 = guesses[g];
    try {
      for (let iter=0; iter<200; iter++) {
        const f = npv(x1), df = d_npv(x1);
        if (Math.abs(df) < 1e-12) break;
        const xNew = x1 - f/df;
        if (!isFinite(xNew)) break;
        if (Math.abs(xNew - x1) < 1e-9) { x1 = xNew; break; }
        x1 = xNew;
      }
      if (isFinite(x1) && Math.abs(npv(x1)) < 1e-4) return Number(x1.toFixed(10));
    } catch(e){}
  }
  return "";
}