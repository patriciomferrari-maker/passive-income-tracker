// =================================================================
// CONFIGURACI√ìN GLOBAL
// =================================================================

// ‚ö†Ô∏è NOTA: La constante CALENDAR_ID (usada aqu√≠) debe estar definida
// en un ARCHIVO SEPARADO de constantes globales para evitar el error
// "Identifier CALENDAR_ID has already been declared".


/**
 * Funci√≥n auxiliar global para sumar o restar meses a una fecha,
 * manteniendo el d√≠a en 1.
 */
function addMonths(d, m) { return new Date(d.getFullYear(), d.getMonth() + m, 1); }


/**
 * -----------------------------------------------------------------
 * FUNCI√ìN PRINCIPAL: INICIO DE TODOS LOS PROCESOS
 * -----------------------------------------------------------------
 * Ejecuta el Cashflow y la Calendarizaci√≥n de Ajustes y Vencimientos.
 * Esta es la funci√≥n que debes ejecutar manualmente.
 */
function INICIO_GENERAL() {
  generarCashflowsConFormulas();      // Genera y actualiza la hoja Cashflow
  calendarizarAjustesIPC();          // Calendariza los recordatorios de ajuste IPC
  calendarizarVencimientoContrato(); // Calendariza recordatorios de vencimiento
}


// =================================================================
// FUNCI√ìN 1: GENERACI√ìN Y C√ÅLCULO DEL CASHFLOW (Cashflow Alquileres)
// =================================================================

/**
 * Genera Cashflow interactivo, incluyendo la l√≥gica para TC Cierre Mes (Col P).
 */
function generarCashflowsConFormulas() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const cond = ss.getSheetByName("Base Alquileres");
  const ipcSheet = ss.getSheetByName("IPC");
  const tc = ss.getSheetByName("TC");
  if (!cond || !ipcSheet || !tc) {
    SpreadsheetApp.getUi().alert("Faltan hojas requeridas: Base Alquileres, IPC o TC");
    return;
  }

  // --- Leer IPC en memoria (array de [date(ms), value])
  const ipcLastRow = ipcSheet.getLastRow();
  const ipcRaw = ipcLastRow > 1 ? ipcSheet.getRange(2,1, ipcLastRow-1, 2).getValues() : [];
  const ipcData = ipcRaw
    .filter(r => r[0] instanceof Date && r[1] !== "" && !isNaN(parseFloat(r[1])))
    .map(r => [ new Date(r[0].getFullYear(), r[0].getMonth(), 1).getTime(), parseFloat(r[1]) ])
    .sort((a,b) => a[0] - b[0]);

  let lastIPCDate = null;
  if (ipcData.length > 0) {
      lastIPCDate = new Date(ipcData[ipcData.length - 1][0]);
  }

  function getIPCforMonth(date) {
    if (!date || !(date instanceof Date)) return 0;
    const key = new Date(date.getFullYear(), date.getMonth(), 1).getTime();
    for (let i = 0; i < ipcData.length; i++) {
      if (ipcData[i][0] === key) return ipcData[i][1];
    }
    return 0;
  }

  // --- Leer TC en memoria (para encontrar TC base)
  const tcLastRow = tc.getLastRow();
  const tcRaw = tcLastRow > 1 ? tc.getRange(2,1, tcLastRow-1, 5).getValues() : []; 
  const tcData = tcRaw
    .filter(r => r[0] instanceof Date && r[4] !== "" && !isNaN(parseFloat(r[4]))) 
    .map(r => [ r[0].getTime(), parseFloat(r[4]) ])
    .sort((a,b) => a[0] - b[0]);

  // Funci√≥n para obtener TC de cierre para TC Base Contrato (TC de cierre del mes ANTES de iniciar contrato)
  function getTCforMonth(date) {
      if (!date || !(date instanceof Date)) return 0;
      const targetDate = new Date(date.getFullYear(), date.getMonth() + 1, 0); 
      let latestTC = 0;
      
      for (let i = 0; i < tcData.length; i++) {
          const tcDate = new Date(tcData[i][0]);
          if (tcDate.getTime() <= targetDate.getTime()) {
              latestTC = tcData[i][1];
          } else {
              break; 
          }
      }
      return latestTC; 
  }
  
  // --- Leer contratos desde Base Alquileres
  const condLast = cond.getLastRow();
  const condRangeRows = Math.max(0, condLast - 1);
  const condData = condRangeRows > 0 ? cond.getRange(2, 1, condRangeRows, Math.max(8, cond.getLastColumn())).getValues() : [];
  const contratos = condData.filter(r => r[0] && r[4]);

  // ‚ö†Ô∏è HEADER ACTUALIZADO: Se agrega la columna "Estado Inflaci√≥n" (Columna Q)
  const header = [
    "Fecha","ID","Propiedad","Moneda","AlquilerInicial","MesIndex","AdjStart",
    "IPC mensual","IPC acumulado per√≠odo ajuste","TC","Valor ARS","Valor USD",
    "Inflaci√≥n Acumulada","Devaluaci√≥n Acumulada", "TC Base Contrato", "TC Cierre Mes",
    "Estado Inflaci√≥n" // Nueva columna Q
  ];
  const rows = [header];


  contratos.forEach(contract => {
    const propiedad = String(contract[0]);
    const moneda = (contract[1] || "ARS").toString().toUpperCase();
    const tipoAjuste = (contract[2] || "IPC").toString().toUpperCase();
    const periodicidad = parseInt(contract[3]) || 12;
    const fechaConcertRaw = contract[4];
    const fechaConcert = (fechaConcertRaw instanceof Date) ? new Date(fechaConcertRaw.getFullYear(), fechaConcertRaw.getMonth(), 1) : null;
    const plazo = parseInt(contract[5]) || 12;
    const alquilerInicial = parseFloat(contract[6]) || 0;
    const id = (contract[7] && contract[7].toString()) ? contract[7].toString() : (propiedad + "-" + (fechaConcert ? fechaConcert.getFullYear() : "NA"));

    if (!fechaConcert) return;

    // Calcular TC Base para Devaluaci√≥n
    const startMonthTCDate = addMonths(fechaConcert, -1);
    const tcStartValue = getTCforMonth(startMonthTCDate);

    for (let m = 0; m < plazo; m++) {
      const pagoFecha = addMonths(fechaConcert, m);
      const targetRow = rows.length + 1;
      const aCell = `A${targetRow}`;
      const dCell = `D${targetRow}`;
      const eCell = `E${targetRow}`;
      const fCell = `F${targetRow}`;
      const kPrevCell = `K${targetRow - 1}`;
      
      // Columnas importantes
      const mCell = `M${targetRow}`; // Col M: Inflaci√≥n Acumulada
      const oCell = `O${targetRow}`; // Col O: TC Base Contrato
      const pCell = `P${targetRow}`; // Col P: TC Cierre Mes (√öltimo TC absoluto)


      // C√°lculo de IPC acumulado (en script)
      let ipcAccumValue = "";
      if (moneda !== "USD" && tipoAjuste === "IPC") {
        const isAdjustmentMonth = (m % periodicidad === 0 && m !== 0);
        if (isAdjustmentMonth) {
            const lastMonthNeeded = addMonths(fechaConcert, m - 1);
            if (!lastIPCDate || lastMonthNeeded.getTime() > lastIPCDate.getTime()) {
                ipcAccumValue = 0; 
            } else {
              const adjStart = addMonths(fechaConcert, m - periodicidad);
              let prod = 1;
              for (let k = 0; k < periodicidad; k++) {
                const monthDate = addMonths(adjStart, k);
                const ipcVal = getIPCforMonth(monthDate);
                prod *= (1 + (isNaN(ipcVal) ? 0 : ipcVal));
              }
              ipcAccumValue = prod - 1;
            }
        } else {
            ipcAccumValue = 0;
        }
      }

      // Inflaci√≥n y Devaluaci√≥n Acumulada (en script)
      let inflationValue = "";
      let devaluationFormula = "";
      
      if (m === 0) {
          inflationValue = 0; 
          devaluationFormula = 0; 
      } 
      else if (lastIPCDate && pagoFecha.getTime() <= lastIPCDate.getTime()) {
        let prod = 1;
        for (let k = 0; k < m; k++) {
            prod *= (1 + (isNaN(getIPCforMonth(addMonths(fechaConcert, k))) ? 0 : getIPCforMonth(addMonths(fechaConcert, k))));
        }
        inflationValue = prod - 1;

        if (tcStartValue !== 0) {
           // Usar TC Cierre Mes (P) para la Devaluaci√≥n
           devaluationFormula = `=IF(ISBLANK(${pCell}); ""; (${pCell}/${oCell})-1)`; 
        } else {
           devaluationFormula = 0;
        }
      }
      
      // 1. TC (Columna J): F√ìRMULA SOLICITADA (Mantener)
      const tcFormula = 
        `=IFERROR(XLOOKUP(DATE(YEAR(${aCell});MONTH(${aCell});1); TC!$A:$A; TC!$E:$E; ""; -1); "")`;

      // 2. TC Cierre Mes (Columna P): F√ìRMULA CORREGIDA (Mantener)
      const tcCierreMesFormula = 
        `=IFERROR(XLOOKUP(EOMONTH(${aCell};0); TC!$A:$A; TC!$E:$E; ""; -1); "")`;
      
      // Valor ARS: L√≥gica de ajuste (Corregida)
      const valorARSFormula =
        `=IF(UPPER(${dCell})="ARS";` +
          `IF(${fCell}=1; ${eCell}; IF(I${targetRow}=0; ${kPrevCell}; ${kPrevCell}*(1+I${targetRow})));` +
          `IF(UPPER(${dCell})="USD"; IF(${pCell}=""; ""; ${eCell}*${pCell}); ""))`;

      // Valor USD: (Corregida)
      const valorUSDFormula =
        `=IF(UPPER(${dCell})="USD"; ${eCell}; IF(UPPER(${dCell})="ARS"; IF(${pCell}=""; ""; K${targetRow}/${pCell}); ""))`;

      // 3. Estado Inflaci√≥n (Columna Q): F√ìRMULA SOLICITADA
      const estadoInflacionFormula = 
        `=IF(${mCell}<>"";"Hay dato";"No hay dato")`;


      // AdjStart to show:
      let adjStartForRow;
      if (moneda !== "USD" && tipoAjuste === "IPC" && (m % periodicidad === 0 && m !== 0)) {
        adjStartForRow = addMonths(fechaConcert, m - periodicidad);
      } else {
        adjStartForRow = addMonths(fechaConcert, Math.floor(m / periodicidad) * periodicidad);
      }

      const row = [
        pagoFecha, id, propiedad, moneda, alquilerInicial, m + 1, adjStartForRow,
        `=IF(UPPER(${dCell})="USD"; ""; IFERROR(VLOOKUP(DATE(YEAR(${aCell});MONTH(${aCell});1); IPC!$A:$B; 2; FALSE); LOOKUP(2;1/(IPC!$A:$A<=DATE(YEAR(${aCell});MONTH(${aCell});1)); IPC!$B:$B)))`, // Col H
        (ipcAccumValue === "" ? "" : ipcAccumValue), // Col I
        tcFormula, // Col J
        valorARSFormula, // Col K 
        valorUSDFormula, // Col L 
        inflationValue, // Col M
        devaluationFormula, // Col N 
        tcStartValue, // Col O
        tcCierreMesFormula, // Col P
        estadoInflacionFormula // Col Q: NUEVA COLUMNA
      ];
      rows.push(row);
    }
  });

  // --- Escribir hoja Cashflow Alquileres (sobrescribir)
  let sh = ss.getSheetByName("Cashflow Alquileres");
  if (sh) sh.clear({ contentsOnly: true });
  else sh = ss.insertSheet("Cashflow Alquileres");

  sh.getRange(1, 1, rows.length, rows[0].length).setValues(rows);

  // Formato y ocultaci√≥n de columnas
  sh.getRange(2, 1, Math.max(1, rows.length - 1), 1).setNumberFormat("yyyy-mm-dd");
  sh.getRange(2, 7, Math.max(1, rows.length - 1), 1).setNumberFormat("yyyy-mm-dd");
  sh.getRange(2, 9, Math.max(1, rows.length - 1), 1).setNumberFormat("0.00%");
  sh.getRange(2, 13, Math.max(1, rows.length - 1), 2).setNumberFormat("0.00%");
  
  sh.hideColumns(15); 
  sh.getRange(2, 16, Math.max(1, rows.length - 1), 1).setNumberFormat("0.000"); 

  ensureOnEditTrigger();

  SpreadsheetApp.getUi().alert("‚úÖ Cashflow generado y trigger de actualizaci√≥n garantizado (se actualizar√° al editar la hoja IPC).");
}


// =================================================================
// FUNCI√ìN 2: CALENDARIZACI√ìN DE AJUSTES DE ALQUILERES (AJUSTADA)
// =================================================================

function calendarizarAjustesIPC() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const cond = ss.getSheetByName("Base Alquileres");

  if (!cond) return;
  
  let calendar;
  // Se asume que CALENDAR_ID est√° definido globalmente
  try {
      calendar = CalendarApp.getCalendarById(CALENDAR_ID);
  } catch (e) {
      SpreadsheetApp.getUi().alert("‚ùå ERROR en Ajustes: No se pudo encontrar el calendario con el ID especificado. Verifique el CALENDAR_ID.");
      return;
  }

  const today = new Date();
  const nextThreeYears = addMonths(today, 36); 
  const condLast = cond.getLastRow();
  const condRangeRows = Math.max(0, condLast - 1);
  const condData = condRangeRows > 0 ? cond.getRange(2, 1, condRangeRows, Math.max(8, cond.getLastColumn())).getValues() : [];
  const contratos = condData.filter(r => r[0] && r[4]);

  let count = 0;
  const searchKey = 'Ajuste IPC: ';
  
  // 1. Limpieza de eventos anteriores
  const eventsToDelete = calendar.getEvents(today, nextThreeYears, {search: searchKey});
  eventsToDelete.forEach(event => {
    if (event.getTitle().includes(searchKey)) {
        event.deleteEvent();
    }
  });

  // 2. Creaci√≥n de nuevos eventos
  contratos.forEach(contract => {
    const propiedad = String(contract[0]); 
    const tipoAjuste = (contract[2] || "IPC").toString().toUpperCase(); 
    const periodicidad = parseInt(contract[3]) || 12; 
    const fechaConcertRaw = contract[4]; 
    const fechaConcert = (fechaConcertRaw instanceof Date) ? new Date(fechaConcertRaw.getFullYear(), fechaConcertRaw.getMonth(), 1) : null;
    const plazo = parseInt(contract[5]) || 12; 
    const id = (contract[7] && contract[7].toString()) ? contract[7].toString() : propiedad; 

    if (!fechaConcert || tipoAjuste !== "IPC" || periodicidad <= 0) return;
    
    for (let m = 0; m < plazo; m++) {
        const isAdjustmentMonth = (m % periodicidad === 0 && m !== 0);
        
        if (isAdjustmentMonth) {
            const adjustmentDate = addMonths(fechaConcert, m);
            const startTime = new Date(adjustmentDate.setHours(10, 0, 0, 0));
            const endTime = new Date(adjustmentDate.setHours(10, 30, 0, 0)); 
            
            const title = `${searchKey}${propiedad} (${id})`; 
            const description = "üö® Este mes toca actualizar el valor del alquiler (Ajuste por IPC acumulado del per√≠odo anterior).";

            // CREAR EVENTO
            const event = calendar.createEvent(title, startTime, endTime, {
                description: description
            });
             
            // A√ëADIR RECORDATORIO: 0 minutos antes (El mismo d√≠a a las 10:00 AM)
            event.addPopupReminder(0); 
            
            count++;
        }
    }
  });
}

// =================================================================
// FUNCI√ìN 3: CALENDARIZACI√ìN DE VENCIMIENTO DE CONTRATOS (AJUSTADA)
// =================================================================

/**
 * Crea eventos en el calendario 3 meses antes del vencimiento del contrato.
 * El T√çTULO del evento incluye la fecha exacta de vencimiento.
 */
function calendarizarVencimientoContrato() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const cond = ss.getSheetByName("Base Alquileres");
  const today = new Date();
  
  if (!cond) return;

  let calendar;
  // Se asume que CALENDAR_ID est√° definido globalmente
  try {
      calendar = CalendarApp.getCalendarById(CALENDAR_ID);
  } catch (e) {
      SpreadsheetApp.getUi().alert("‚ùå ERROR en Vencimiento: No se pudo encontrar el calendario con el ID especificado. Verifique el CALENDAR_ID.");
      return;
  }
  
  const condLast = cond.getLastRow();
  const condRangeRows = Math.max(0, condLast - 1);
  const condData = condRangeRows > 0 ? cond.getRange(2, 1, condRangeRows, Math.max(8, cond.getLastColumn())).getValues() : [];
  const contratos = condData.filter(r => r[0] && r[4]);

  let count = 0;
  
  const searchKey = 'Vencimiento Contrato: ';
  const nextFiveYears = addMonths(today, 60); 

  // 1. Limpieza: Elimina recordatorios de vencimiento previos
  const eventsToDelete = calendar.getEvents(today, nextFiveYears, {search: searchKey});
  eventsToDelete.forEach(event => {
    if (event.getTitle().includes(searchKey)) {
        event.deleteEvent();
    }
  });

  // 2. Creaci√≥n de Nuevos Eventos
  contratos.forEach(contract => {
    const propiedad = String(contract[0]); 
    const fechaConcertRaw = contract[4]; 
    const fechaConcert = (fechaConcertRaw instanceof Date) ? new Date(fechaConcertRaw.getFullYear(), fechaConcertRaw.getMonth(), 1) : null;
    const plazo = parseInt(contract[5]) || 12; 
    const id = (contract[7] && contract[7].toString()) ? contract[7].toString() : propiedad; 

    if (!fechaConcert || plazo <= 0) return;
    
    // C√°lculo de fechas:
    // Fecha de Vencimiento: √öltimo d√≠a del √∫ltimo mes de contrato (Mes Concert + Plazo)
    const contractExpirationDate = new Date(fechaConcert.getFullYear(), fechaConcert.getMonth() + plazo, 0); 
    // Fecha de Recordatorio: 3 meses antes del primer d√≠a del mes de vencimiento
    const monthsBefore = 3;
    const fechaRecordatorio = addMonths(fechaConcert, plazo - monthsBefore);
    
    // Solo si el recordatorio es un mes futuro (o el mes actual)
    if (fechaRecordatorio.getTime() >= addMonths(today, -1).getTime()) {
        
        const startTime = new Date(fechaRecordatorio.setHours(10, 0, 0, 0));
        const endTime = new Date(fechaRecordatorio.setHours(10, 30, 0, 0)); 
        
        const formattedExpirationDate = Utilities.formatDate(contractExpirationDate, Session.getScriptTimeZone(), "dd/MM/yyyy");
        
        // T√çTULO ACTUALIZADO: Incluye la fecha de vencimiento.
        const title = `${searchKey}${propiedad} (${id}) - Vence el ${formattedExpirationDate}`; 
        
        // Descripci√≥n que mantiene la explicaci√≥n.
        const description = `Ultimos 3 meses de alquiler. El contrato finaliza el ${formattedExpirationDate}. Toca revisar la situaci√≥n del inquilino y negociar la renovaci√≥n/salida.`;

        // CREAR EVENTO
        const event = calendar.createEvent(title, startTime, endTime, {
            description: description
        });

        // A√ëADIR RECORDATORIO: 0 minutos antes (El mismo d√≠a a las 10:00 AM)
        event.addPopupReminder(0);
        
        count++;
    }
  });

  if (count > 0) {
      SpreadsheetApp.getUi().alert(`‚úÖ Se crearon ${count} recordatorios de vencimiento de contrato en el calendario: ${calendar.getName()}.`);
  }
}

// =================================================================
// FUNCIONES DE TRIGGER (Mecanismo de Auto-Actualizaci√≥n)
// =================================================================

function ensureOnEditTrigger() {
  const projectTriggers = ScriptApp.getProjectTriggers();
  projectTriggers.forEach(t => {
    try {
      const et = t.getEventType && t.getEventType();
      const h = t.getHandlerFunction && t.getHandlerFunction();
      if (et === ScriptApp.EventType.ON_EDIT && h === "onEditTriggerHandler") {
        ScriptApp.deleteTrigger(t);
      }
    } catch (e) {}
  });

  ScriptApp.newTrigger("onEditTriggerHandler")
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();
}

function onEditTriggerHandler(e) {
  try {
    if (!e || !e.range) return;
    const sheet = e.range.getSheet();
    if (!sheet) return;
    const name = sheet.getName();
    if (name !== "IPC") return;
    
    generarCashflowsConFormulas();
  } catch (err) {
    console.error("onEditTriggerHandler error:", err);
  }
}

function removeAllGeneratedTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  for (const t of triggers) {
    ScriptApp.deleteTrigger(t);
  }
}